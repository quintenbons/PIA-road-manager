<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Header Example</title>
    <style>
      body {
        font-family: "Arial", sans-serif;
        margin: 0;
        padding: 0;
      }
      header {
        width: 100%;
        height: 3em;
        background-color: #666;
        padding: 0 2em;
        display: flex;
        align-items: center;
        gap: 1em;
      }
      main {
        padding: 0 2em;
      }
      .logo {
        height: 80%;
        display: inline-block;
        background-size: contain;
        background-repeat: no-repeat;
      }
      .title {
        display: inline-block;
        vertical-align: middle;
        font-size: 24px;
        color: white;
      }
      .subtitle {
        font-size: 18px;
        color: white;
        margin-top: 5px;
      }
      .date {
        font-size: 16px;
        color: #666;
        margin-top: 10px;
      }
      figure {
        text-align: center;
        margin: 2em;
      }
      figcaption {
        margin-top: 0.5em;
        font-style: italic;
        color: #555;
      }
    </style>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // Function to convert number to Roman numerals
        function toRoman(num) {
          const roman = {
            M: 1000,
            CM: 900,
            D: 500,
            CD: 400,
            C: 100,
            XC: 90,
            L: 50,
            XL: 40,
            X: 10,
            IX: 9,
            V: 5,
            IV: 4,
            I: 1,
          };
          let str = "";

          for (let i of Object.keys(roman)) {
            let q = Math.floor(num / roman[i]);
            num -= q * roman[i];
            str += i.repeat(q);
          }

          return str;
        }

        // Update h1 elements with Roman numerals
        let h1s = document.getElementsByTagName("h1");
        for (let i = 0; i < h1s.length; i++) {
          h1s[i].textContent = toRoman(i + 1) + " - " + h1s[i].textContent;
        }

        // Update h2 elements with "Parent Roman numeral.Subsection number"
        const h2s = document.getElementsByTagName("h2");
        let currentH1Index = 0; // Start from the first h1 element
        let h2Counter = 1; // Subsection counter

        for (let h2 of h2s) {
          // Check if this h2 is still under the current h1
          if (h2.previousElementSibling.tagName === "H1") {
            h2Counter = 1; // Reset counter for new section
            currentH1Index++; // Move to next h1
          }
          h2.textContent =
            toRoman(currentH1Index) + "." + h2Counter + " - " + h2.textContent;
          h2Counter++;
        }

        const mainElement = document.getElementById("summary");
        h1s = document.getElementsByTagName("h1");
        let summaryHTML = "<h2>Sommaire</h2><ul>";

        // Iterate over each h1 to create main list items
        for (let i = 0; i < h1s.length; i++) {
          summaryHTML += `<li>${h1s[i].textContent}</li>`;
          let nextElem = h1s[i].nextElementSibling;
          let h2List = "";

          // Iterate over sibling elements to find all h2s following this h1
          while (nextElem && nextElem.tagName !== "H1") {
            if (nextElem.tagName === "H2") {
              h2List += `<li>${nextElem.textContent}</li>`;
            }
            nextElem = nextElem.nextElementSibling;
          }

          // If there were h2s, add them as a nested list
          if (h2List) {
            summaryHTML += `<ul>${h2List}</ul>`;
          }
        }

        summaryHTML += "</ul>";
        mainElement.innerHTML = summaryHTML;
      });
    </script>
  </head>
  <body>
    <header>
      <img src="images/logo_ensimag.png" alt="Logo ensimag" class="logo" />
      <div class="title">
        Projet Intelligence Artificielle - Gestion du trafic par IA
      </div>
      <div class="subtitle">Présentation du projet</div>
    </header>

    <main>
      <section id="summary"></section>

      <h1>Architecture Préliminaire de l'IA</h1>

      <h2>Introduction</h2>

      <p>
        La simulation du réseau routier de Grenoble est un projet complexe
        visant à simuler fidèlement les conditions de circulation urbaine.
        Initialement, notre projet envisageait de créer une intelligence
        artificielle unique ayant la maîtrise sur l'ensemble des feux de
        signalisation de la ville, décidant du comportement de chaque feu.
        Cependant, cette méthode a soulevé deux problématiques majeures :
        premièrement, la génération des données d'entrée était excessivement
        longue, rendant cette approche peu pratique compte tenu du volume des
        données requises. Deuxièmement, l'ampleur des données d'entrée soulevait
        des inquiétudes quant à la capacité du système à converger vers une
        solution efficace.
      </p>

      <p>
        Pour pallier à ces défis, nous avons modifié notre stratégie. Plutôt que
        d'avoir une seule IA pour tout le réseau, notre système se compose
        désormais d'une multitude d'IA, chacune gérant un noeud spécifique du
        réseau, c'est-à-dire une intersection avec ses feux de signalisation.
        Ainsi, chaque IA est responsable de tous les feux d'une intersection
        donnée et doit optimiser la circulation à ce point précis. Les noeuds
        reçoivent des flux de véhicules sur les routes entrantes et chaque IA
        s'efforce de minimiser la congestion en contrôlant efficacement les feux
        de son intersection.
      </p>

      <p>
        Cette nouvelle méthode a pour objectif de trouver une optimisation
        locale pour chaque scénario, qui dépend de divers facteurs comme le flux
        de voitures, le nombre de routes connectées à l'intersection, et les
        caractéristiques propres à chaque route. Nous espérons ainsi que les IA
        trouvent les optimisations locales, ce qui (nous l'espérons) contribuera
        à une amélioration globale et coordonnée de la circulation sur
        l'ensemble du réseau routier.
      </p>

      <h2>Flux d'utilisation</h2>

      <figure>
        <img src="./images/summary-drawing.png" alt="Plan global d'exécution" />
        <figcaption>Plan global d'exécution</figcaption>
      </figure>

      <p>
        L'intelligence artificielle utilisée est un réseau neuronal dense à 4
        étages. Il utilisera donc 2 "hidden layers", chacun constitué de 64
        neurones.
      </p>

      <ul>
        <li>
          L'entrée correspond à l'état d'une intersection, ainsi que des
          évènements issus de la simulation sur les 15 minutes précédentes. Il
          est important d'inclure dans cette entrée la stratégie précédemment
          choisie, ainsi que la congestion (terme qui n'est pas encore défini
          mathématiquement dans notre modèle).
        </li>
        <li>
          La sortie correspond à un choix de stratégie (one hot, choisi avec un
          softmax) à prendre pour les 15 prochaines minutes pour une
          intersection donnée. Cette stratégie est un algorithme conçu par nos
          soins. Il est important ici d'avoir des stratégies cohérentes avec le
          monde réel, mais aussi adaptables au nombre d'entrées/sorties de
          l'intersection sur laquelle on l'utilise.
        </li>
      </ul>

      <p>
        Cela signifie que l'IA aura un impact uniquement toutes les 15 minutes,
        et qu'elle n'a d'informations que sur une seule intersection. Cela nous
        semblait raisonable sous quelques hypothèses:
      </p>
      <ul>
        <li>Le modèle du trafic ne varie pas beaucoup en 15 minutes</li>
        <li>
          Une intersection est affectée par les intersections environnentes,
          mais il est possible de très bien gérer une intersection sans avoir à
          communiquer avec les intersections voisines.
        </li>
      </ul>

      <!-- TODO missing part: strategies -->

      <h1>Entraînement du Modèle</h1>

      <h2>Format des Données d'entraînement</h2>

      <p>
        Pour entraîner efficacement notre modèle d'intelligence artificielle
        basé sur PyTorch, il est essentiel d'avoir des datasets structurés pour
        une utilisation avec des dataloaders. Ces datasets permettront de
        nourrir et d'affiner le modèle d'IA, en fournissant une source de
        données cohérente et structurée, adaptée aux spécificités de
        l'apprentissage automatique.
      </p>
      <p>
        Nous estimons qu'un volume conséquent, de plusieurs millions d'exemples
        au moins, sera nécessaire pour atteindre une efficacité optimale.
      </p>

      <p>Le dataset sera constitué de tuples (I, E).</p>
      <ul>
        <li>
          I (input) correspond à une entrée du réseau neuronal pour une
          intersection donnée. I contient aussi des informations sur les
          évènements des 15 minutes précédentes.
        </li>
        <li>
          E (expected) correspond au résultat attendu "expected", qui devra être
          généré algorithmiquement.
        </li>
      </ul>

      <p>
        Cette approche structurée permettra à notre modèle de s'adapter et
        d'apprendre efficacement à partir d'un large éventail de scénarios de
        trafic.
      </p>

      <h2>Génération des données d'entrée</h2>

      <figure>
        <img
          src="./images/dataset-generation.png"
          alt="Génération d'une entrée du dataset"
          style="height: 20%"
        />
        <figcaption>Génération d'une entrée du dataset</figcaption>
      </figure>

      <p>
        La génération de jeux de données pour entraîner notre IA est un
        processus clé, impliquant la création de configurations spécifiques pour
        simuler divers scénarios de trafic urbain. Il est important de rappeler
        que notre modèle n'est conscient que d'une seule intersection, ce qui
        nous permet de simplifier drastiquement la génération des datasets, en
        limiant la simulation à un seul noeud.
      </p>

      <p>
        Pour générer une entrée de dataset (I, E), la simulation est d'abord
        exécutée pendant 15 minutes avec une stratégie sélectionnée
        uniformément, sur une configuration aléatoire. À l'issue de cette
        période, le paramètre I de l'entrée de dataset peut être calculé à
        partir des informations mesurées pendant l'exécution.
      </p>

      <p>
        Il faut ensuite générer le paramètre E, qui correspond au meilleur choix
        possible de stratégie pour les 15 minutes suivantes. Pour cela, nous
        pouvons simplement exécuter les stratégies une par une, et récupérer
        celle qui obtient le meilleur score (le moins de congestion). Attention
        ici à bien utiliser la même configuration de trafic que pour les 15
        minutes initiales pour ne pas enfreindre notre hypothèse de consistence
        du trafic.
      </p>

      <figure id="close-second">
        <img
          src="./images/dataset-hesitation.png"
          alt="Hésitation sur la sortie attendue"
          style="height: 20%"
        />
        <figcaption>Hésitation sur la sortie attendue</figcaption>
      </figure>

      <p>
        Un cas particulier est à prévoir (voir
        <a href="#close-second">@close-second</a>) : si plusieurs stratégies
        sont correctes, pénaliser le modèle lors du backwards peut être néfaste.
        C'est pourquoi nous détecterons ces situations afin de les exclure du
        dataset.
      </p>

      <p>
        Il est possible à l'avenir que nous reviendrons sur cette décision afin
        de permettre à l'intelligence artificielle d'apprendre à résoudre des
        dilemmes plus efficacement.
      </p>
    </main>
  </body>
</html>
